#pragma once
#include "seuYacc.h"

//    dfa items(G'){
//       将C初始化为CLOUSURE（{[S'->・S,$]}）；
//       repeat
//           for(C中的每个项集I)
//              for(每个文法符号X)
//                 if(GOTO(I,X)非空且不在C中){
//                      将GOTO(I,X)加入C中；
//                      构造一条I到C，的X边；}
//       until 不再有新的项加入C 中；
//       return C； }
// 构造lr1dfa
bool SeuYacc::init_lr1_dfa() {
	/*
	我们应该先构造S'->S，$，然后把他作为初始状态，而不是直接将第一个产生式作为初始状态
	*/
	//ProductionItem super_start_production;
	ElementType super_right = (*_productionVector.begin())._head;
	list<ElementType> super_bodyList;
	super_bodyList.push_back(super_right);
	ProductionItem super_start_production(_word.size()+1, super_bodyList,1, _productionVector.size()+1);

	//构造初始状态
	LR1State START_STATE;
	set<unsigned int> predSet;
	predSet.insert(_terminalTable.find("$")->second);
	//LR1Item temp(&super_start_production, predSet);
    LR1Item temp(&*_productionVector.begin(), predSet);
    START_STATE.addItem(temp);
	LR1State closure_of_startstate = Closure(START_STATE);
	TransitionItem temp_tran_item(closure_of_startstate, 0);
	_LR1stateTransition.push_back(temp_tran_item);

	unsigned int maxState = 1;
	for (unsigned int k = 0; k < maxState; ++k) {
		// check all symbols whether current state has a out-edge
		for (IDType edge = 0; edge < _indexSymbol; ++edge) {
			LR1State newState = GOTO(_LR1stateTransition.at(k)._lr1state, edge);
			if (!newState._itemList.empty()) {
				bool newStateFlag = true;
				for (auto& m : _LR1stateTransition) {
					if (m._lr1state.equal(newState)) {
						_LR1stateTransition.at(k)._transMap.insert(std::make_pair(edge, m._index));//插入边
						newStateFlag = false;
						break;
					}
				}
				if (newStateFlag) {//向LR1转换表中添加新的状态
					_LR1stateTransition.push_back(TransitionItem(newState, maxState));//插入新状态
					_LR1stateTransition.at(k)._transMap.insert(std::make_pair(edge, maxState));//插入新边
					maxState++;
				}
			}
		}
	}
	return true;
}

/*
构造语法分析表
输入：一个增广文法G'
输出：G'的lr语法分析表的函数action和goto
方法：
1）构造G'的lrdfa
2）语法分析器的状态i根据Ii构造得到。状态i的语法分析动作按照下面的规则确定
	1、如果[A->x・aB，b]在Ii中，且goto（Ii，a）=Ij，那么把action[i,a]设置为"移入j"（a是一个终结符号
	2、如果[A->x・,a]在Ii中，并且A!=S'，那么action[i,a]设置为"规约A->x"
	3、如果[S'->S・，$]在Ii中，设置action[i,$]为"接受"
3）状态i相对于各个非终结符的goto函数：如果goto（Ii，A）=Ij，那么goto[i,A]=j
4）其他未设置的项为error
5）初始状态是包含[S'->S・，$]的状态
*/
// 构造语法分析表
void SeuYacc::construct_lr1_table() {
	//构造lr1状态转换表
	for (unsigned int state = 0; state < _LR1stateTransition.size(); ++state) {
		vector<TableItem> temp(_indexSymbol);
		// for end state, make reduction action
		for (auto& p : _LR1stateTransition.at(state)._lr1state._itemList) {//遍历当前状态的lr1项集的每个项
			if (p._dot == p._prod->_bodyList.end()) {//如果点在末尾，是规约动作
				for (auto& pred : p._predSet) {
					TableItem& curItem = temp.at(pred);
					switch (curItem._action) {
					case ERROR:
						// no table item now
						curItem = TableItem(REDUCTION, p._prod->_index);// terminal, action reduction
						if (p._prod->_index == 0)
							curItem = TableItem(ACCEPT, p._prod->_index);// terminal, action reduction
						break;
					default:
						break;
					}
				}
			}
		}
		
		for (auto& tran : _LR1stateTransition.at(state)._transMap) {//遍历当前状态的所有出边
			TableItem& curItem = temp.at(tran.first);
			if (curItem._action == ERROR) {
				if (_nonterminalNullable.find(tran.first) == _nonterminalNullable.end())
					curItem = TableItem(SHIFT, tran.second);// terminal, action
				else
					curItem = TableItem(GOTO_STATE, tran.second);// nonterminal, goto
			}
			else if (curItem._action == REDUCTION) {//移入，规约冲突
				// solving shift-reduce conflixt
				// reduce action is done before
				unsigned int reduceOP = _indexSymbol;
				// find the last terminial as reduceOP
				auto list = _productionVector.at(curItem._index)._bodyList;
				for (auto it = list.rbegin(); it != list.rend(); ++it) {
					if (_nonterminalNullable.find(*it) == _nonterminalNullable.end()) {
						reduceOP = *it;
						break;
					}
				}
				if (reduceOP != _indexSymbol && conflict_solve(tran.first, reduceOP) == SHIFT) {
					curItem = TableItem(SHIFT, tran.second);
				}
			}
			else if (curItem._action == SHIFT) {
			}
			else {
			}
		}
		_LR1parseTable.push_back(temp);
	}
}

void SeuYacc::output_table() {
	std::ofstream out("tableYacc.cpp");
	out << "/*\n";
	out << "* tableYacc.h \n";
	out << "* auto generated by SeuYacc::output_table()\n";
	out << "*/\n";

	out << "#include \"DataStructureDefine.h\"\n";
	out << "#include \"generateHead.h\"\n";
	out << "using namespace std;\n";
	out << "\n";
	out << "void initTable(map<unsigned int, map<string, TableItem> >& _parseTable) {\n";
	out << "map<string, TableItem> tran;\n";
	out << "map<string, TableItem> temp;\n";
	if (!_LALR1parseTable.empty()) {
		for (auto& item : _LALR1parseTable) {
			out << "// state " << item.first << std::endl;
			for (ElementType edge = 0; edge < _indexSymbol; ++edge) {
				if (item.second[edge]._action != ERROR) {
					out << "tran.insert(make_pair(\"" << _word.at(edge) << "\", TableItem("
						<< item.second[edge]._action << "," << item.second[edge]._index << ")));\n";
				}
			}
			out << "_parseTable.insert(make_pair(" << item.first << ",tran));\n";
			
			out << "tran.swap(temp);\n";
			out << "temp.clear();\n";
			out << std::endl;
		}
	}
	else {
		for (int i = 0; i < _LR1parseTable.size(); ++i) {
			out << "// state " << i << std::endl;
			auto& item = _LR1parseTable.at(i);
			for (ElementType edge = 0; edge < _indexSymbol; ++edge) {
				if (item.at(edge)._action != ERROR) {
					out << "tran.insert(std::make_pair(\"" << _word.at(edge) << "\", TableItem("
						<< item.at(edge)._action << "," << item.at(edge)._index << ")));\n";
				}
			}
			out << "_parseTable.insert(make_pair(" << i << ",tran));\n";
			out << "tran.swap(temp);\n";
			out << "temp.clear();\n";
			out << std::endl;
		}
	}

	out << "}\n";
	out.close();
}


// 一些辅助函数

//  setOfOtems CLOUSURE(I){
//   repeat
//     for(I中每一项[A->x・By,a])
//         for(G'中的每一个产生式B->z)
//             for(First(ya)中的每个终结符号b)
//                  将[B->・z,b]加入到集合I中；
//    until 不能向I加入更多的项；
//    return I；
//    }
// 求CLOSURE(X)闭包的函数
// return  : Clousure(T)
SeuYacc::LR1State SeuYacc::Closure(LR1State lr1state) {
	for (auto& A : lr1state._itemList) {
		// dot at the end
		if (A._dot == A._prod->_bodyList.end()) {
			continue;
		}
		for (auto& it2 : _productionVector) {
			if (it2._head == *(A._dot)) {
				auto next = A._dot; ++next;
				// A->B, add B->xxx to T
				if (next == A._prod->_bodyList.end()) {
					LR1Item temp(&it2, A._predSet);
					lr1state.addItem(temp);
				}
				else {
					auto found = _nonterminalNullable.find(*next);
					if (found == _nonterminalNullable.end()) {
						// A->a.Bb b, b is terminal
						set<ElementType> set; set.insert(*next);
						LR1Item temp(&it2, set);
						lr1state.addItem(temp);
					}
					else if (found->second) {
						// A->a.BCDE.., C can be empty
						set<ElementType> firstC = First(*next);
						firstC.erase(find(firstC.begin(), firstC.end(), EPLISON)); // erase empty
						firstC.insert(A._predSet.begin(), A._predSet.end()); // copy preSet to first(C)

						// add first(symbol DE...) to firstC
						auto next2 = next; ++next2;
						while (next2 != A._prod->_bodyList.end()) {
							auto found2 = _nonterminalNullable.find(*next2);
							if (found2 == _nonterminalNullable.end()) {
								// A->a.BCDE..., next2 D is terminal
								set<ElementType> set; set.insert(*next);
								firstC.insert(*next2);
								break;
							}
							// A->a.BCDE..., next2 D can be empty
							else if (found2->second) {
								set<ElementType> firstD = First(*next2);
								firstD.erase(find(firstD.begin(), firstD.end(), EPLISON)); // erase empty
								firstC.insert(firstD.begin(), firstD.end());
								++next2;
							}
							// A->a.BCDE..., next2 D can not be empty
							else {
								set<ElementType> firstD = First(*next2);
								firstC.insert(firstD.begin(), firstD.end());
								break;
							}
						}
						LR1Item temp(&it2, firstC);
						lr1state.addItem(temp);
					}
					else {
						// A->a.BCD, C can not be empty
						LR1Item temp(&it2, First(*next));
						lr1state.addItem(temp);
					}

				}
			}
		} // end for each in _productionVector
	} // end for each in T._itemList
	return lr1state;
}

//    setOfOtems GOTO（I,X）{
//       将J初始化为空集；
//       for(I中的每一个项[A->x・Xy,a])
//           将项[A->x・Xy,a]加入到集合J中；
//       retrun CLOUSURE(J);
//    }
// 求GOTO（X）的函数
// return  : GOTO(T)
SeuYacc::LR1State SeuYacc::GOTO(LR1State lr1state, unsigned int edge) {
	LR1State result;
	for (auto& it : lr1state._itemList) {
		if (it._dot != it._prod->_bodyList.end() && *(it._dot) == edge) {
			// shift, reserve same predictive symbol
			LR1Item item(it);
			++(item._dot);
			result.addItem(item);
		}
	}
	if (!result._itemList.empty())
		return Closure(result);
	else
		return result; // no such transition edge
}

// 求FIRST集的函数
// input  : unsigned int X
// return  : First(X)
set<SeuYacc::ElementType> SeuYacc::First(ElementType X) {
	// check whether First(X) has done
	auto foundFirstSet = _firstMap.find(X);
	if (foundFirstSet != _firstMap.end()) return foundFirstSet->second;
	// calculate First(X)
	std::set<ElementType> result;
	auto foundX = _nonterminalNullable.find(X);
	if (foundX == _nonterminalNullable.end()) {
		// X is terminal, First(X) = {X}
		result.insert(X);
	}
	else {
		if (foundX->second == true) {
			result.insert(EPLISON); // X can be empty
		}
		// find all productions with X as head
		for (auto& it : _productionVector) {
			if (it._head == X) {
				if (it._bodyList.empty()) continue; // X->empty
				if (*it._bodyList.begin() == X) continue; // X->X...
				for (auto it2 : it._bodyList) {
					//X->AYB
					auto foundA = _nonterminalNullable.find(it2);
					if (foundA == _nonterminalNullable.end()) {
						// A is terminal, add A to First(X)
						result.insert(it2);
						break;
					}
					else if (foundA->second == false) {
						// A is terminal and A is not nullable, add First(A) to First(X)
						std::set<ElementType> firstIT2 = First(it2);
						result.insert(firstIT2.begin(), firstIT2.end());
						break;
					}
					else {
						// A is terminal and A is nullable, add {First(A)-EPLISON} to First(X) 
						std::set<ElementType> firstIT2 = First(it2);
						firstIT2.erase(find(firstIT2.begin(), firstIT2.end(), EPLISON)); // erase empty
						result.insert(firstIT2.begin(), firstIT2.end());
					}
				}
			}
		}
	}
	_firstMap.insert(std::make_pair(X, result));
	return result;
}

// 求FOLLOW集的函数
// input  : unsigned int X
// return : Follow(X)
set<SeuYacc::ElementType> SeuYacc::Follow(ElementType X) {
	std::set<ElementType> result;
	if (_productionVector.begin()->_head == X)  // X is start symbol
		result.insert(_terminalTable.find("$")->second);
	for (auto& it : _productionVector) {
		for (auto it2 = it._bodyList.begin(), it2End = it._bodyList.end(); it2 != it2End; ++it2) {
			if (*it2 == X) {
				// A->abcdXBCD..., next is B 
				auto next = it2; ++next;
				if (next == it2End) {
					if (it._head == X) break; // X->XB
					// A->abcdX, add first(A) to Follow(X)
					std::set<ElementType> firstIT2 = First(it._head);
					result.insert(firstIT2.begin(), firstIT2.end());
					break;
				}
				else {
					if (_nonterminalNullable.find(*next)->second == false) {
						// A->abcdXB..., B is not nullable, add first(B) to Follow(X)
						std::set<ElementType> firstIT2 = First(*next);
						result.insert(firstIT2.begin(), firstIT2.end());
						break;
					}
					else {
						// A->abcdXB..., B is nullable, add {first(B)-EPLISON} to Follow(X)
						std::set<ElementType> firstIT2 = First(*next);
						firstIT2.erase(find(firstIT2.begin(), firstIT2.end(), EPLISON)); // erase EPLISON

						// A->abcdXBCDE..., add first(symbol DE...) to firstC
						auto next2 = next; ++next2;
						while (next2 != it2End) {
							auto found2 = _nonterminalNullable.find(*next2);
							if (found2 == _nonterminalNullable.end()) {
								//A->aXBCDE..., next2 is terminal, add it to First(it2)
								firstIT2.insert(*next2);
								break;
							}
							else if (found2->second) {
								//A->aXBCDE..., next2 can be empty, add {First(D)-EPLISON} to First(C)
								std::set<ElementType> firstD = First(*next2);
								firstD.erase(find(firstD.begin(), firstD.end(), EPLISON)); // erase empty
								firstIT2.insert(firstD.begin(), firstD.end());
								//++next2; // ?? need checking
							}
							else {
								//A->aXBCDE..., next2 can not be empty, add First(D) to First(C)
								std::set<ElementType> firstD = First(*next2);
								firstIT2.insert(firstD.begin(), firstD.end());
								break;
							}
							++next2;
						}
						// add first(C) to Follow(X)
						result.insert(firstIT2.begin(), firstIT2.end());
						break;
					}
				}
			}
		}
	} // end for each in _productionVector
	return result;
}

SeuYacc::ACTION_TYPE SeuYacc::conflict_solve(ElementType shiftOP, ElementType reduceOP) {
	auto sOp = _priority.find(shiftOP), rOp = _priority.find(reduceOP);

	if (sOp == _priority.end()) return REDUCTION;
	else if (rOp == _priority.end()) return SHIFT;
	else {
		// both priority is declared in file
		if (sOp->second < rOp->second) return REDUCTION;
		else if (rOp->second < sOp->second) return SHIFT;
		else {
			// equal priority, then judge left associatity
			return _leftAssociative.at(shiftOP) ? REDUCTION : SHIFT;
		}
	}
}